<!DOCTYPE html><html lang="en-US" xml:lang="en-US">
  
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="shortcut icon" type="image/png" sizes="32x32" href="https://hemomorphic.alexblood.net/favicon-32x32.png">
<link rel="alternate" type="application/atom+xml" title="Atom feed" href="https://hemomorphic.alexblood.net/atom.xml">
<link rel="stylesheet" href="https://hemomorphic.alexblood.net/main.css">
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<script async src="https://www.googletagmanager.com/gtag/js?id=example-tracking-id"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'example-tracking-id');
</script>

<meta name="robots" content="index, follow">
<meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">

<title>// sql-docs: published on crates.io! | Hemo-Morphic</title>
<meta name="generator" content="Zola">
<meta name="description" content="cargo publish sql-docsI am happy to announce that I have completed my first crate and published it to crates.io!experience --sql-docs creationThis crate has a pretty specific use case for extracting c…">
<meta name="author" content="Alex Blood">
<link rel="canonical" href="https://hemomorphic.alexblood.net/posts/sql-docs/">
  <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://hemomorphic.alexblood.net/images/logo.png">
  <meta name="twitter:title" content="&#x2F;&#x2F; sql-docs: published on crates.io!">
  <meta name="twitter:description" content="cargo publish sql-docsI am happy to announce that I have completed my first crate and published it to crates.io!experience --sql-docs creationThis crate has a pretty specific use case for extracting c…">
  
  <meta property="og:title" content="&#x2F;&#x2F; sql-docs: published on crates.io!">
  <meta property="og:description" content="cargo publish sql-docsI am happy to announce that I have completed my first crate and published it to crates.io!experience --sql-docs creationThis crate has a pretty specific use case for extracting c…">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://hemomorphic.alexblood.net/posts/sql-docs/">
    <meta property="og:image" content="https://hemomorphic.alexblood.net/images/logo.png">

  <meta property="og:site_name" content="&#x2F;&#x2F; sql-docs: published on crates.io!">
  <meta property="og:locale" content="en_US">
    <meta property="article:published_time" content="2026-01-25T19:47:08+08:00">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://hemomorphic.alexblood.net/posts/sql-docs"
      },
      "headline": "&#x2F;&#x2F; sql-docs: published on crates.io!",
      "description": "cargo publish sql-docsI am happy to announce that I have completed my first crate and published it to crates.io!experience --sql-docs creationThis crate has a pretty specific use case for extracting c…",
      "wordcount": "1899",
      "datePublished": "2026-01-25T19:47:08+08:00",
      "dateModified": "2026-01-25T19:47:08+08:00",
      "author": {
        "@type": "Person",
        "name": "Alex Blood"
      },
      "publisher": {
        "@type": "Organization",
        "name": "&#x2F;&#x2F; sql-docs: published on crates.io!",
        "logo": {
          "@type": "ImageObject",
          "url": "https://hemomorphic.alexblood.net/images/logo.png"
        }
      }
    }
    </script>

</head>

<body>
  <header>
    <div class="container">
      <a id="a-title" href="https://hemomorphic.alexblood.net">
        <h1>Hemo-Morphic</h1>
      </a>
      <h2>Static dispatch in my bloodstream</h2>
      <nav id="navbar">
  <a href="https://hemomorphic.alexblood.net/about" class="btn">About</a>
  <a href="https://hemomorphic.alexblood.net/tags" class="btn">Tags</a>
  <a href="https://github.com/rpg-alex" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
  <a href="https://buymeacoffee.com/rpg.alex" class="btn">☕ Support me</a>
</nav>
</div>
  </header>

  <div class="container">
    <main>
<article class="page">
  <div class="header-container">
    <h2>&#x2F;&#x2F; sql-docs: published on crates.io!</h2>
    <div class="improve hide-on-mobiles">
      
<a href="https://github.com/rpg-alex/hemomorphic/edit/master/content/posts/sql-docs.md" title="Help improve page https://hemomorphic.alexblood.net/posts/sql-docs/">Improve this page</a>

    </div>
  </div>
  <div class="page-info">
    <span>Tags = [
      <a href="https://hemomorphic.alexblood.net/tags/rust/" class="page-tag">rust</a>,
      <a href="https://hemomorphic.alexblood.net/tags/blogging/" class="page-tag">blogging</a>,
      <a href="https://hemomorphic.alexblood.net/tags/sql/" class="page-tag">sql</a>,
      <a href="https://hemomorphic.alexblood.net/tags/parsing/" class="page-tag">parsing</a>,
      <a href="https://hemomorphic.alexblood.net/tags/project/" class="page-tag">project</a> ]
    </span>
    <time class="page-time smaller" datetime="2026-01-25T19:47:08+08:00">
      Posted on January 25, 2026 at 19:47 +08
    </time>
  </div>
  <div class="entry">
    <h1 id="cargo-publish-sql-docs">cargo publish <a href="https://crates.io/crates/sql_docs"><code>sql-docs</code></a></h1>
<p>I am happy to announce that I have completed my first crate and published it to <em><a href="https://crates.io">crates.io</a></em>!</p>
<span id="continue-reading"></span><h2 id="experience-sql-docs-creation">experience --sql-docs creation</h2>
<p>This crate has a pretty specific use case for extracting comments from <code>sql</code> files. I learned quite a bit about <a href="https://en.wikipedia.org/wiki/Parsing">parsers</a>, as well as creating more idiomatic Rust. I started the project with an idea of the externally facing APIs I wanted to write. However I wound up making several revisions that led to much cleaner APIs and drove me into using a <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html"><code>builder</code> pattern</a>. Moreover, I finally had an excuse to work with <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">lifetimes</a> and while only for one struct, and technically only for one field in that struct, I did have a good reason to do so.</p>
<p>I also gained a lot of experience writing my own tests and then creatively adding test helper functions. Overall I learned to write tests that I think are clear and genuinely test expected functionality.</p>
<p>Finally, my crate has been integrated into another repo called <a href="https://github.com/earth-metabolome-initiative/sql-traits">sql-traits</a>, and the real time feedback I received to make sure <code>sql-docs</code> was up to snuff performance wise was the cherry on top for this experience.</p>
<h2 id="project-goal">// project-goal</h2>
<p>The goal for this project was to take an SQL file such as:</p>
<pre data-lang="sql" style="background-color:#2b2c2f;color:#cccece;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#5f6364;">-- Table that houses user data 
</span><span style="color:#c594c5;">CREATE TABLE </span><span style="color:#6699cc;">users</span><span> (
</span><span>    </span><span style="color:#5f6364;">-- primary key for table 
</span><span>    id          </span><span style="color:#c594c5;">INT PRIMARY KEY</span><span>,
</span><span>    </span><span style="color:#5f6364;">-- field for storing usernames. max of 50 characters
</span><span>    username    </span><span style="color:#c594c5;">VARCHAR</span><span>(</span><span style="color:#f99157;">50</span><span>) </span><span style="color:#5fb3b3;">NOT </span><span style="color:#f99157;">NULL</span><span>,
</span><span>    ...
</span><span>);
</span></code></pre>
<p>This is a pretty generic example but it shows the kinds of comments I would like to extract from the SQL data. The goal would be to extract the comments, and structure them like this:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span>TableDoc </span><span style="color:#5fb3b3;">{
</span><span>    schema</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">None</span><span style="color:#5fb3b3;">,
</span><span>    name</span><span style="color:#5fb3b3;">: &quot;</span><span style="color:#99c794;">users</span><span style="color:#5fb3b3;">&quot;,
</span><span>    doc</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Some</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">Table that houses user data</span><span style="color:#5fb3b3;">&quot;),
</span><span>    columns</span><span style="color:#5fb3b3;">: </span><span>vec!</span><span style="color:#5fb3b3;">[
</span><span>        ColumnDoc </span><span style="color:#5fb3b3;">{
</span><span>            name</span><span style="color:#5fb3b3;">: &quot;</span><span style="color:#99c794;">id</span><span style="color:#5fb3b3;">&quot;,
</span><span>            doc</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Some</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">primary key for table</span><span style="color:#5fb3b3;">&quot;)
</span><span>        </span><span style="color:#5fb3b3;">},
</span><span>        ColumnDoc </span><span style="color:#5fb3b3;">{
</span><span>            name</span><span style="color:#5fb3b3;">: &quot;</span><span style="color:#99c794;">username</span><span style="color:#5fb3b3;">&quot;,
</span><span>            doc</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Some</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">field for storing usernames. max of 50 characters</span><span style="color:#5fb3b3;">&quot;)
</span><span>        </span><span style="color:#5fb3b3;">}
</span><span>    </span><span style="color:#5fb3b3;">],
</span><span>    path</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Some</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">mysqlfile.sql</span><span style="color:#5fb3b3;">&quot;)
</span><span style="color:#5fb3b3;">}
</span></code></pre>
<p>This structure is handy as it groups the comments by table and column, and accounts for a potential <code>schema</code> that may be present. One of the first things you'll notice is the metadata on the table. the <code>path</code> field wound up being important later on for an API endpoint I needed to add for parsing from <code>String</code>s.</p>
<h3 id="intended-use">//intended-use</h3>
<p>The top level API that is the entry point for the crate is a structure called <code>SqlDoc</code>:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#5f6364;">/// Top-level documentation object containing all discovered [`TableDoc`] entries.
</span><span style="color:#5fb3b3;">#[</span><span>derive</span><span style="color:#5fb3b3;">(</span><span>Clone</span><span style="color:#5fb3b3;">,</span><span> Debug</span><span style="color:#5fb3b3;">,</span><span> Eq</span><span style="color:#5fb3b3;">,</span><span> PartialEq</span><span style="color:#5fb3b3;">)]
</span><span style="color:#c594c5;">pub struct </span><span>SqlDoc </span><span style="color:#5fb3b3;">{
</span><span>    </span><span style="color:#5f6364;">/// Holds the [`Vec`] of all tables found in all specified files.
</span><span>    tables</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Vec</span><span style="color:#5fb3b3;">&lt;</span><span>TableDoc</span><span style="color:#5fb3b3;">&gt;</span><span>,
</span><span style="color:#5fb3b3;">}
</span></code></pre>
<p><code>SqlDoc</code> itself is just a wrapper struct around the <code>Vec&lt;TableDoc&gt;</code> but with integration with a builder struct and some handy methods like:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span> </span><span style="color:#c594c5;">pub fn </span><span style="color:#6699cc;">table</span><span style="color:#5fb3b3;">(&amp;</span><span style="color:#f99157;">self</span><span>, </span><span style="color:#f99157;">name</span><span style="color:#5fb3b3;">: &amp;</span><span style="color:#c594c5;">str</span><span>, </span><span style="color:#f99157;">schema</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Option</span><span style="color:#5fb3b3;">&lt;&amp;</span><span style="color:#c594c5;">str</span><span style="color:#5fb3b3;">&gt;) -&gt; </span><span style="color:#fac863;">Result</span><span style="color:#5fb3b3;">&lt;&amp;</span><span>TableDoc, DocError</span><span style="color:#5fb3b3;">&gt;
</span></code></pre>
<p>Which lets you find a single <code>TableDoc</code> and runs in <code>O(log n)</code> thanks to using binary search to find the table and possibly duplicates that may exist (which would be bad).</p>
<h2 id="example-of-sqldoc-intended-use">/// Example of [<code>SqlDoc</code>] intended use</h2>
<p>The crate's API implements a builder and can look like this:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c594c5;">use </span><span>sql_docs</span><span style="color:#5fb3b3;">::</span><span>SqlDoc</span><span style="color:#5fb3b3;">;
</span><span>
</span><span style="color:#c594c5;">let</span><span> generated_docs </span><span style="color:#5fb3b3;">= </span><span>SqlDoc</span><span style="color:#5fb3b3;">::</span><span>from_dir</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">the_dir</span><span style="color:#5fb3b3;">&quot;).</span><span style="color:#6699cc;">deny</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">deny.sql</span><span style="color:#5fb3b3;">&quot;).</span><span style="color:#6699cc;">build</span><span style="color:#5fb3b3;">();
</span></code></pre>
<p>In the above code snippet, a <code>dir</code> is specified. There are three primary constructors:</p>
<ol>
<li>
<p><code>from_dir("Path")</code>: The most robust entry route for the crate. This will create an <code>SqlDocBuilder</code> struct and populate the <code>source</code> field of the builder, and then the chained <code>deny("deny.sql")</code> will populate the <code>deny</code> field, which is a vector of <code>Strings</code> that are used at build time to filter out any undesired SQL files (note that non SQL files are automatically filtered).</p>
</li>
<li>
<p><code>from_path("Path")</code>: This method expects the specific path for a single <code>sql</code> file and will also return an <code>SqlDocBuilder</code> instance, though the <code>deny()</code> doesn't apply.</p>
</li>
<li>
<p><code>from_str("str")</code>: If the <code>sql</code> statements and comments in question already reside in a <code>str</code> somewhere, this method allows the comments to be parsed without the need for a file. This method was created for the purpose of fuzzing and is utilized in the fuzz harness I wrote.</p>
</li>
</ol>
<p>Regardless of method chosen, all will return a <code>SqlDocBuilder</code> and then to complete the operation the method <code>build()</code> is invoked, to actually build the <code>SqlDoc</code>! This all sounds very reasonable but this was the first time I had tried implementing a builder and indeed the first time encountering a builder. I am now a big fan of builders and find myself wondering "do I need a builder for this?" more and more when working on new stuff.</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c594c5;">enum </span><span>SqlFileDocSource&lt;&#39;a&gt; </span><span style="color:#5fb3b3;">{
</span><span>    Dir</span><span style="color:#5fb3b3;">(</span><span>PathBuf</span><span style="color:#5fb3b3;">),
</span><span>    File</span><span style="color:#5fb3b3;">(</span><span>PathBuf</span><span style="color:#5fb3b3;">),
</span><span>    FromString</span><span style="color:#5fb3b3;">(&amp;</span><span style="color:#c594c5;">&#39;a str</span><span style="color:#5fb3b3;">),
</span><span style="color:#5fb3b3;">}
</span></code></pre>
<p>The source is stored in an enum, which helps streamline the <code>build</code> process.</p>
<p>Notice that this is where I got to use an explicit lifetime, as the <code>FromString</code> enum variant contains a <code>str</code> which requires specifying the lifetime! Why do this? A <code>String</code> would probably be fine but given the <code>FromString</code> is mostly intended to be used for parsing, it would be nice to avoid using the heap and adding any overhead, as this crate was intended to at least try to be performant!</p>
<h2 id="cargo-sql-docs-docs">cargo sql-docs --docs</h2>
<p>For this project I used very strict linting rules to ensure I wasn't getting lazy and help me avoid accidentally running into any <em>antipatterns</em>:</p>
<pre data-lang="toml" style="background-color:#2b2c2f;color:#cccece;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#5fb3b3;">[lints.rust]
</span><span style="color:#eb606b;">missing_docs </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unreachable_patterns </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unused_must_use </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unused_import_braces </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unconditional_recursion </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unused_macro_rules </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">deprecated </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unsafe_code </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span>
</span><span style="color:#5fb3b3;">[lints.clippy]
</span><span style="color:#eb606b;">unreadable_literal </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">allow</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">missing_panics_doc </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">allow</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">struct_excessive_bools </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">allow</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">should_panic_without_expect </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">allow</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">clone_on_copy </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">forbid</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">unwrap_used </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">expect_used </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;
</span><span style="color:#eb606b;">pedantic </span><span style="color:#5fb3b3;">= { </span><span style="color:#eb606b;">level </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;, </span><span style="color:#eb606b;">priority </span><span style="color:#5fb3b3;">= -</span><span style="color:#f99157;">1 </span><span style="color:#5fb3b3;">}
</span><span style="color:#eb606b;">cargo </span><span style="color:#5fb3b3;">= { </span><span style="color:#eb606b;">level </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;, </span><span style="color:#eb606b;">priority </span><span style="color:#5fb3b3;">= -</span><span style="color:#f99157;">1 </span><span style="color:#5fb3b3;">}
</span><span style="color:#eb606b;">nursery </span><span style="color:#5fb3b3;">= { </span><span style="color:#eb606b;">level </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">deny</span><span style="color:#5fb3b3;">&quot;, </span><span style="color:#eb606b;">priority </span><span style="color:#5fb3b3;">= -</span><span style="color:#f99157;">1 </span><span style="color:#5fb3b3;">}
</span><span style="color:#eb606b;">multiple_crate_versions </span><span style="color:#5fb3b3;">= &quot;</span><span style="color:#99c794;">allow</span><span style="color:#5fb3b3;">&quot;
</span></code></pre>
<p>While this may seem a bit masochistic, I think in light of recent Rust events, like <a href="https://news.ycombinator.com/item?id=45974052">CloudFlare's use of <code>unwrap()</code> in production</a>, not permitting myself to make the same type of mistakes seemed like a no brainer for ensuring my crate was safe for other people to rely on.</p>
<p>Of specific note was the <code>missing_docs = "forbid"</code> which at first I despised as I felt it slowed me down, but having it turned on forced me to write my documentation after I had added a new <code>Struct</code> or a new method or even a new field to a <code>Struct</code>.</p>
<p>As a result, when I actually ran <code>cargo doc</code> my documentation was clear and with the heavier linting happening, my <code>README.md</code> examples were also tested and I could be confident I really was shipping something that would work out of the box and as advertised.</p>
<h3 id="parse-help">parse --help</h3>
<p>The main challenge with this project was creating a parser that would account for a few invariants:</p>
<ol>
<li>
<p>Comments are only parsed if they immediately precede a statement</p>
</li>
<li>
<p>Single Line <code>--</code> comments and Multiline <code>/* */</code> comments are both valid</p>
</li>
<li>
<p>SQL Statements themselves need to be valid before parsing their comments</p>
</li>
</ol>
<p>With these concepts in mind I got to work. <code>3</code> was the easiest for me to implement thanks to the <a href="https://github.com/apache/datafusion-sqlparser-rs">datafusion-sqlparser-rs</a> crate; which I used to parse the SQL Statements. If the <code>sql</code> was parsed successfully then I would take the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> of statements and compare that against an AST of comments that is generated alongside the SQL Statements. And from there I'd generate my <code>SqlDocs</code>!</p>
<h4 id="span-start-span-end">span.start() &amp;&amp; span.end()</h4>
<p>I looked into how DataFusion was parsing sql and noticed that they track the <code>span</code> of each statement, a span struct looking like this:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c594c5;">pub struct </span><span>Location </span><span style="color:#5fb3b3;">{
</span><span>    line</span><span style="color:#5fb3b3;">: </span><span style="color:#c594c5;">u64</span><span>,
</span><span>    column</span><span style="color:#5fb3b3;">: </span><span style="color:#c594c5;">u64</span><span>,
</span><span style="color:#5fb3b3;">}
</span><span style="color:#c594c5;">pub struct </span><span>Span </span><span style="color:#5fb3b3;">{
</span><span>    start</span><span style="color:#5fb3b3;">:</span><span> Location,
</span><span>    end</span><span style="color:#5fb3b3;">:</span><span> Location,
</span><span style="color:#5fb3b3;">}
</span></code></pre>
<p>This is my version of a <code>Span</code> that has a start and end <code>Location</code>. It basically mirrors the structure of the DataFusion parser's <code>Span</code> structure, and serves the same purpose. Great! Now once I have parsed a comment I can compare it with the starting span of each parsed statement and if the comment's start <code>Location</code> is one line above the statement, then add that comment to my AST!</p>
<h4 id="scan-comments-sql">scan_comments(sql)</h4>
<p>To accomplish parsing the sql comments I created a pretty hefty method called <code>scan_comments()</code> that would take the <code>sql</code> file data as an input and then collect all valid comments.</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c594c5;">pub fn </span><span style="color:#6699cc;">scan_comments</span><span style="color:#5fb3b3;">(</span><span style="color:#f99157;">src</span><span style="color:#5fb3b3;">: &amp;</span><span style="color:#c594c5;">str</span><span style="color:#5fb3b3;">) -&gt; </span><span>CommentResult</span><span style="color:#5fb3b3;">&lt;</span><span style="color:#c594c5;">Self</span><span style="color:#5fb3b3;">&gt; 
</span></code></pre>
<p>I got a little fancy with this and you'll notice I have a custom <code>Result</code> that looks like this:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#5f6364;">/// Alias for comment results that may return a [`CommentError`]
</span><span style="color:#c594c5;">pub type </span><span>CommentResult</span><span style="color:#5fb3b3;">&lt;</span><span>T</span><span style="color:#5fb3b3;">&gt; = </span><span style="color:#fac863;">Result</span><span style="color:#5fb3b3;">&lt;</span><span>T, CommentError</span><span style="color:#5fb3b3;">&gt;;
</span></code></pre>
<p>The parsing in <code>scan_comments(..)</code> goes line by line, and specifically keeps track of whether or not it's already in a <code>multiline</code> comment or a <code>single line</code> comment, and if the parser is in a comment it collects the <code>char</code>s until it's no longer in a comment. Along the way I needed to add a few errors and tried to use my new <code>Span</code> and <code>Location</code> data to help make the errors more useful for the user.</p>
<p>I utilized a <code>match</code> statement against 3 different values I used to track: <code>in_single</code>, <code>in_multi</code>, <code>c</code>. The first two are of course simply <code>bool</code> and track if you are in a comment or not. The <code>c</code> is the current <code>char</code> to be evaluated. Thus parsing simply becomes going line by line, looking for the characters marking a comment, and then once they are found, adding everything after them to the vector of comments.</p>
<p>The parsing logic for ending a single line comment is pretty straightforward, anything on a line proceeding the <code>--</code> is taken as a comment, and once that line has ended, <code>in_single</code> is set back to <code>false</code>, marking the end of the comment. Then the comment is collected.</p>
<p>It is similar for multiline comments but there are a couple caveats here as well:</p>
<ul>
<li>
<p>Multiline comments must have an ending <code>*/</code> to mark their comment end.</p>
</li>
<li>
<p>Multiline comments are going to be on potentially... multiple lines! Thus when splitting line by line this needs to be accounted for.</p>
</li>
</ul>
<p>Once comments are parsed and collected for a file, they are then passed along to be compared against the parsed SQL Statements and if they are valid then they are finally returned!</p>
<h2 id="cargo-nightly-fuzz-run-sql-docs">cargo +nightly fuzz run sql_docs</h2>
<p>Fuzzing is quickly becoming one of my favorite things. For the uninitiated fuzzing is basically brute-force testing your code, and in my case, for any code state that could result in an unexpected <code>panic!</code> due to some bug in my code. Fuzzing is cool, it uses mutations, and <a href="https://en.wikipedia.org/wiki/Fuzzing">everyone is doing it</a>!</p>
<p>For this crate, I used <a href="https://github.com/rust-fuzz/cargo-fuzz">cargo fuzz</a>, which uses <code>libFuzzer</code>. I am quite new to writing a harness, which is the code the fuzzer will use as the entry point to your software, and at first I was using the default <code>&amp;[u8]</code> for fuzzing, but after getting some feedback was able to understand that I could get away with using a <code>String</code> for fuzzing. My fuzzer looked like this:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#5fb3b3;">#![</span><span>no_main</span><span style="color:#5fb3b3;">]
</span><span>
</span><span style="color:#c594c5;">use </span><span>libfuzzer_sys</span><span style="color:#5fb3b3;">::</span><span>fuzz_target</span><span style="color:#5fb3b3;">;
</span><span style="color:#c594c5;">use </span><span>std</span><span style="color:#5fb3b3;">::</span><span>str</span><span style="color:#5fb3b3;">;
</span><span>
</span><span style="color:#c594c5;">use </span><span>sql_docs</span><span style="color:#5fb3b3;">::</span><span>SqlDoc</span><span style="color:#5fb3b3;">;
</span><span>
</span><span>fuzz_target!</span><span style="color:#5fb3b3;">(|</span><span style="color:#f99157;">data</span><span style="color:#5fb3b3;">:</span><span> String</span><span style="color:#5fb3b3;">| {
</span><span>    </span><span style="color:#c594c5;">let </span><span style="color:#5fb3b3;">_ = </span><span>SqlDoc</span><span style="color:#5fb3b3;">::</span><span>from_str</span><span style="color:#5fb3b3;">(&amp;</span><span>data</span><span style="color:#5fb3b3;">)
</span><span>        </span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">deny</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">a.sql</span><span style="color:#5fb3b3;">&quot;)
</span><span>        </span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">deny</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">b.sql</span><span style="color:#5fb3b3;">&quot;)
</span><span>        </span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">build</span><span style="color:#5fb3b3;">();
</span><span>
</span><span style="color:#5fb3b3;">});
</span></code></pre>
<p>Though in the actual fuzzer I wrote in each variant on the builder that existed, each target item served the same purpose, to test as many possible inputs as possible and try to find somewhere I was still getting <code>panics!</code>. Luckily, after hours of running, Not a single crash was found!</p>
<h2 id="performance-assumptions-and-iterative-improvements">// Performance Assumptions and Iterative Improvements</h2>
<p>I was originally just adding each <code>Table</code> that I found to my <code>Vec&lt;TableDoc&gt;</code> inside of <code>SqlDoc</code>, but had it quickly pointed out to me that I was not sorting my tables and had made my <code>table()</code> method <code>O(n²)</code> in complexity for simply searching for a single table (of which there could hundreds or thousands of tables)! I realized I could add one single line at creation of the <code>SqlDoc</code> that would alleviate all downstream issues, within the <code>SqlDoc</code> <code>new()</code> method itself:</p>
<pre data-lang="rust" style="background-color:#2b2c2f;color:#cccece;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#c594c5;">pub fn </span><span style="color:#6699cc;">new</span><span style="color:#5fb3b3;">(</span><span style="color:#c594c5;">mut </span><span style="color:#f99157;">tables</span><span style="color:#5fb3b3;">: </span><span style="color:#fac863;">Vec</span><span style="color:#5fb3b3;">&lt;</span><span>TableDoc</span><span style="color:#5fb3b3;">&gt;) -&gt; </span><span style="color:#c594c5;">Self </span><span style="color:#5fb3b3;">{
</span><span>        tables</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">sort_by</span><span style="color:#5fb3b3;">(|</span><span style="color:#f99157;">a</span><span style="color:#5fb3b3;">, </span><span style="color:#f99157;">b</span><span style="color:#5fb3b3;">| </span><span>a</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">name</span><span style="color:#5fb3b3;">().</span><span style="color:#6699cc;">cmp</span><span style="color:#5fb3b3;">(</span><span>b</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">name</span><span style="color:#5fb3b3;">()));
</span><span>        </span><span style="color:#c594c5;">Self </span><span style="color:#5fb3b3;">{</span><span> tables </span><span style="color:#5fb3b3;">}
</span><span>    </span><span style="color:#5fb3b3;">}
</span></code></pre>
<p>Just sort the Tabledocs by name now! Which meant that downstream binary searching could be confidently utilized and cut down in overhead by a LOT!</p>
<p>There were a few other spots where I made assumptions based on getting things working first, and then later needed to go back and make revisions but sorting tables (and later columns of tables too) was probably the biggest on performance.</p>
<h2 id="conclusion">// Conclusion</h2>
<p>This project was an exciting excuse to dive into parsing, crate creation, documentation generation, and fuzzing, all topics I am interested in getting better with and using more! I am happy with the work I did. While this is a niche crate, having something up on crates.io that I wrote myself feels good. I have a few things in the pipeline for upcoming projects and can say my experience on this crate has given me the confidence and knowledge to work on these projects. Thanks for reading!</p>

  </div><div class="giscus comments"></div>
<script src="https://giscus.app/client.js"
        data-repo="rpg-alex&#x2F;hemomorphic"
        data-repo-id="R_kgDOQVq14Q"
        data-category="Blog comments"
        data-category-id="DIC_kwDOQVq14c4CzJUG"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="transparent_dark"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>

    </main>
  </div>
  <footer><a href="mailto:mralexblood@outlook.com"><i class="svg-icon icon-mail"></i></a><a href="https://github.com/rpg-alex"><i class="svg-icon icon-github-circled"></i></a><a href="https://buymeacoffee.com/rpg.alex"><img
    class="svg-icon"
    src="https://hemomorphic.alexblood.net/images/bmc-brand-icon.svg"
    alt="☕"
    
  ></a>
<span class="copyright">&copy; 2025 - 2026 Alex Blood</span>
</footer>
  <script src="https://hemomorphic.alexblood.net/js/copy-code.js" defer></script>
</body>

</html>
